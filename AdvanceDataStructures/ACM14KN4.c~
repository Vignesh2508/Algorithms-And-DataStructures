#include<stdio.h>
struct node{
long long sum;
long long min;
long long max;
int inc;
int dec;
};

struct node *decreasing(long long arr[],long long left,long long right,long long l,long long r,long long current_node);
struct node *increasing(long long arr[],long long left,long long right,long long l,long long r,long long current_node);
long long max(long long arr[],long long left,long long right,long long l,long long r,long long current_node);

long long sum(long long arr[],long long left,long long right,long long l,long long r,long long current_node);

struct node *update(long long arr[],long long index,long long newvalue,long long left,long long right,long long current_node);
struct node *build(long long arr[],long long left,long long right,long long current_node);

struct node new,segment[300001],*u;
 int main()
{char ch;
long long j,i,k,l,m,n,arr[100001];
scanf("%lld%lld",&n,&m);
for(i=0;i<n;i++)
scanf("%lld",&arr[i]);
u=build(arr,0,n-1,0);
/*
for(i=0;i<3*n;i++)
printf("%lld %lld %lld %d %d\n",segment[i].sum,segment[i].min,segment[i].max,segment[i].inc,segment[i].dec);
*/
while(m--)
{
scanf(" %c %lld %lld",&ch,&k,&l);
if(ch=='U')
{
arr[k-1]=l;
u=update(arr,k-1,l,0,n-1,0);
}
else if(ch=='M')
{
j=max(arr,0,n-1,k-1,l-1,0);
printf("%lld\n",j);
}
else if(ch=='S')
{
j=sum(arr,0,n-1,k-1,l-1,0);
printf("%lld\n",j);
}
else if(ch=='I')
{
u=NULL;
new.inc=-1;
new.min=0;
new.max=0;
u=increasing(arr,0,n-1,k-1,l-1,0);
if(u!=NULL&&u->inc==1)
printf("1\n");
else
printf("0\n");
}
else 
{u=NULL;
new.dec=-1;
new.min=10000000000;
new.max=10000000000;
u=decreasing(arr,0,n-1,k-1,l-1,0);
if(u!=NULL&&u->dec==1)
printf("1\n");
else
printf("0\n");
}
}
return 0;
}
struct node *build(long long arr[],long long left,long long right,long long current_node)
{
struct node *lnode,*rnode,*tmp;
long long mid;
if(left==right)
{
segment[current_node].sum=arr[left];
segment[current_node].min=arr[left];
segment[current_node].max=arr[left];
segment[current_node].inc=1;
segment[current_node].dec=1;
return &segment[current_node];
}
mid=(left+right)/2;
lnode=build(arr,left,mid,2*current_node+1);
rnode=build(arr,mid+1,right,2*current_node+2);

segment[current_node].sum=lnode->sum+rnode->sum;
if(lnode->min>rnode->min)
segment[current_node].min=rnode->min;
else
segment[current_node].min=lnode->min;
if(lnode->max>rnode->max)
segment[current_node].max=lnode->max;
else
segment[current_node].max=rnode->max;

if(lnode->max<=rnode->min&&lnode->inc==1&&rnode->inc==1)
segment[current_node].inc=1;
else
segment[current_node].inc=0;

if(lnode->min>=rnode->max&&lnode->dec==1&&rnode->dec==1)
segment[current_node].dec=1;
else
segment[current_node].dec=0;

return &segment[current_node];
}

struct node *update(long long arr[],long long index,long long newvalue,long long left,long long right,long long current_node)
{
struct node *lnode,*rnode;
long long mid;
if(index>right||index<left)
return &segment[current_node];

if(left==right&&index==left)
{
arr[index]=newvalue;
segment[current_node].sum=newvalue;
segment[current_node].min=newvalue;
segment[current_node].max=newvalue;
segment[current_node].inc=1;
segment[current_node].dec=1;

return &segment[current_node];
}
mid=(left+right)/2;
lnode=update(arr,index,newvalue,left,mid,2*current_node+1);
rnode=update(arr,index,newvalue,mid+1,right,2*current_node+2);

segment[current_node].sum=lnode->sum+rnode->sum;

if(lnode->min > rnode->min)
segment[current_node].min=rnode->min;
else
segment[current_node].min=lnode->min;

if(lnode->max>rnode->max)
segment[current_node].max=lnode->max;
else
segment[current_node].max=rnode->max;

if(lnode->max<=rnode->min&&lnode->inc==1&&rnode->inc==1)
segment[current_node].inc=1;
else
segment[current_node].inc=0;

if(lnode->min>=rnode->max&&lnode->dec==1&&rnode->dec==1)
segment[current_node].dec=1;
else
segment[current_node].dec=0;

return &segment[current_node];
}


long long max(long long arr[],long long left,long long right,long long l,long long r,long long current_node)
{
long long mid,k,j;

if(l>right||r<left)
return 0;

if(left>=l&&r>=right)
return segment[current_node].max;


mid=(left+right)/2;

k=max(arr,left,mid,l,r,2*current_node+1);
j=max(arr,mid+1,right,l,r,2*current_node+2);

if(k>j)
return k;
else
return j;
}
long long sum(long long arr[],long long left,long long right,long long l,long long r,long long current_node)
{
long long mid;
if(l>right||r<left)
return 0;

if(left>=l&&r>=right)
return segment[current_node].sum;

mid=(left+right)/2;
return sum(arr,left,mid,l,r,2*current_node+1)+
sum(arr,mid+1,right,l,r,2*current_node+2);
//return total;
}

struct node *increasing(long long arr[],long long left,long long right,long long l,long long r,long long current_node)
{
struct node *lnode=NULL,*rnode=NULL;
long long mid;
if(l>right||r<left)
{u=NULL;
return u;}
if(left>=l&&r>=right)
{
if(segment[current_node].inc==0||new.inc==0)
{new.inc=0;
return &new;
}

if(segment[current_node].min>=new.max)
{
new.max=segment[current_node].max;
new.inc=1;
return &new;
}
else
{new.inc=0;return &new;}
}

mid=(left+right)/2;

lnode=increasing(arr,left,mid,l,r,2*current_node+1);
if(lnode!=NULL)
{
if(lnode->inc==0)
return &new;
}

rnode=increasing(arr,mid+1,right,l,r,2*current_node+2);
if(rnode!=NULL)
{if(rnode->inc==0)
return &new;
}

return &new;
}

struct node *decreasing(long long arr[],long long left,long long right,long long l,long long r,long long current_node)
{
struct node *lnode,*rnode;
long long mid;
if(l>right||r<left)
{u=NULL;return u;}
if(left>=l&&r>=right)
{
if(segment[current_node].dec==0||new.dec==0)
{new.dec=0;
return &new;
}

if(segment[current_node].max<=new.min)
{
new.min=segment[current_node].min;
new.dec=1;
return &new;
}
else
{new.dec=0;
return &new;
}
}

mid=(left+right)/2;

lnode=decreasing(arr,left,mid,l,r,2*current_node+1);
if(lnode!=NULL)
{if(lnode->dec==0)
return &new;
}
rnode=decreasing(arr,mid+1,right,l,r,2*current_node+2);
if(rnode!=NULL)
{if(rnode->dec==0)
return &new;
}
return &new;
}




